<?php

// TODO all files unmanaged, in tmp, except zip.
// TODO clean up zip files.

/*
 * Views to query the stored datasets.
 */
 /*
function clio_search_views_default_views() {
  $views = array();
  $path = drupal_get_path('module', 'clio_search') . '/views';
  $files = drupal_system_listing('/.*\.inc$/', $path, 'name', 0);
  foreach($files as $file) {
    include_once $path . '/' . $file->filename;
    $views[$view->name] = $view;
  }
  return $views;
} 
*/

/**
 * Implements hook_menu().
 */
function clio_search_menu() {
  $items = array();
  $items['datasets'] = array(
    'title' => 'Datasets',
    'page callback' => 'datasets_intro',
    'access arguments' => array('search datasets'),
    'expanded' => TRUE,
  );
  $items['datasets/countries'] = array(
    'page callback'    => 'clio_search_list',
    'page arguments'   => array(1),
    'access arguments' => array('search datasets'),
    'type'             => MENU_NORMAL_ITEM,
    'weight' => 10,
  );
  $items['datasets/topics'] = array(
    'page callback'    => 'clio_search_list',
    'page arguments'   => array(1),
    'access arguments' => array('search datasets'),
    'type'             => MENU_NORMAL_ITEM,
    'weight' => 11,
  );
  $items['datasets/indicators'] = array(
    'page callback'    => 'clio_search_list',
    'page arguments'   => array(1),
    'access arguments' => array('search datasets'),
    'type'             => MENU_NORMAL_ITEM,
    'weight' => 12,
  );
  $items['datasets/combined'] = array(
    'page callback'    => 'clio_search_select',
    'page arguments'   => array(1),
    'access arguments' => array('search datasets'),
    'type'             => MENU_NORMAL_ITEM,
    'weight' => 13,
  );
  $items['datasets/select/%/%'] = array(
    'page callback'    => 'clio_search_select',
    'page arguments'   => array(2, 3),
    'access arguments' => array('search datasets'),
    'type'             => MENU_CALLBACK,
  );
  $items['datasets/searchresults'] = array(
    'page callback'    => 'clio_search_results',
    'access arguments' => array('search datasets'),
    'type'             => MENU_CALLBACK,
  );
  $items['datasets/download'] = array(
    'page callback'    => 'clio_search_download',
    'access arguments' => array('download datasets'),
    'type'             => MENU_CALLBACK,
  );
  return $items;
}


/**
 * Implements hook_permission().
 */
function clio_search_permission() {
  return array(
    'search datasets' => array(
      'title' => t('Search and filter datasets'),
    ),
    'download datasets' => array(
      'title' => t('Download search results as zip file'),
    ),
  );
}

function datasets_intro() {
  drupal_goto('datasets/indicators');
}

/*
 * Show a list of countries, indicators or topics.
 * Link to a page to further filter results.
 *
 * Feature clio_indicators_and_countries_views bevat views van termen, 
 * o.b.v. content-type datapoint, met URL rewrite.
 *
 * @param $vocab
 *   Vocabulary name
 * @return
 *   Themed list with links e.g. /clio/datasets/select/country/12
 */
function clio_search_list($vocab) {
  switch ($vocab) {
    case 'countries':
      drupal_set_title('Countries');
//      $output = views_embed_view('countries', 'page');
      $output = clio_search_list_terms('countries');
      break;
    case 'topics':
      drupal_set_title('Topics');
      $output = views_embed_view('indicators', 'page_1');
      break;
    case 'indicators':
    default:
      drupal_set_title('Indicators');
      $output = views_embed_view('indicators', 'page');
      break;
  }
  return $output;
}


/*
 * TODO Use theme_list.
 */
function clio_search_list_terms($vocab_name) {
  $term_list = clio_search_taxonomy_get_leaves($vocab_name);
  $output = '<ul class="country-list">';
  $char = 'A';
  // Hmmm.
  $output .= '<li class="startletter">' . $char . '</li><ul>';          
  foreach ($term_list as $tid => $name) {
    if (mb_substr($name, 0, 1) != $char) {
      $char = mb_substr($name, 0, 1);
      $output .= '</ul><li class="startletter">' . $char . '</li><ul>';          
    }
    $output .= '<li class="country"><a href="/datasets/select/country/' . $tid . '">' . $name . '</a></li>';
  }
  $output .= '</ul></ul>';
  return $output;
}


/*
 * Show a form with select boxes or list of checkboxes (combined, tree view)
 * to select countries, indicators and years.
 *
 * Feature clio_datapoint_and_data_views bevat o.a. view met exposed filters + argument
 * Year (from, to), indicators, countries
 * TODO: change country to countries, topics to topic etc.
 *
 * @param $vocab
 *   Vocabulary name
 * @param $tid
 *   Term ID
 * @return
 *   Themed list with links, e.g.
 *   /clio/datasets/searchresults?year[min]=1500&year[max]=1800&indicator[]=113&indicator[]=304&indicator[]=83
 */
function clio_search_select($vocab = 'combined', $tid = NULL) {
  $term = (arg(3) && is_numeric(arg(3))) ? taxonomy_term_load(arg(3)) : NULL;
  switch ($vocab) {
    case 'country':
      $title = ($term) ? $term->name : 'Select';
      drupal_set_title($title);
      $output = drupal_get_form('clio_search_select_form');
      break;
    case 'indicator':
      $title = ($term) ? $term->name : 'Select';
      drupal_set_title($title);
      $output = drupal_get_form('clio_search_select_form');
      break;
    case 'topic':
      $title = ($term) ? $term->name : 'Select';
      drupal_set_title($title);
      $output = drupal_get_form('clio_search_select_form');
      break;
    case 'combined':
    default:
      drupal_set_title('Combined search');
      $output = views_embed_view('data', 'page_4');
      break;
  }
  return $output;
}


function clio_search_select_form($form, &$form_state) {
  $form['#action'] = url('datasets/searchresults');
  $form['year'] = array (
    '#tree' => TRUE,
    '#title' => t('Time period'),
  );
  $form['year']['min'] = array (
    '#type' => 'textfield',
    '#title' => t('from'),
    '#size' => 4,
    '#default_value' => 1500,
  );
  $form['year']['max'] = array (
    '#type' => 'textfield',
    '#title' => t('to'),
    '#size' => 4,
    '#default_value' => CLIO_MAX_YEAR,
  );

  if (((arg(2) == 'country') || (arg(2) == 'indicator')) && (is_numeric(arg(3)))) {
    $form[arg(2)] = array (
         '#tree' => TRUE,
    );
    $form[arg(2)][] = array (
         '#type' => 'hidden',
         '#value' => arg(3),
    );
  }

  if ((arg(2) == 'country') || (arg(2) == 'topic')) {
    $parent = (arg(2) == 'topic') ? arg(3) : 0;
  
    $form['indicator'] = array(
      '#type' => 'select',
      '#title' => t('Indicators'),
      '#options' => clio_search_taxonomy_get_leaves('indicators', $parent),
      '#multiple' => TRUE,
      '#size' => 14,
    );
  }

  if ((arg(2) == 'indicator') || (arg(2) == 'topic')) {
    $form['country'] = array(
      '#type' => 'select',
      '#title' => t('Countries'),
      '#options' => clio_search_taxonomy_get_leaves('countries'),
      '#multiple' => TRUE,
      '#size' => 14,
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('OK'),
  );

  return $form;  
}


/*
 * Save selected country or indicator between requests.
 * Redirect exposed filter form to results function.
 */
function clio_search_form_views_exposed_form_alter(&$form, &$form_state, $form_id) {
  switch ($form['#id'])  {
    case 'views-exposed-form-data-page-1':
    case 'views-exposed-form-data-page-2':
    case 'views-exposed-form-data-page-3':
    case 'views-exposed-form-data-page-4':
      $form['#action'] = url('datasets/searchresults');
      if (((arg(3) == 'country') || (arg(3) == 'indicator')) && (is_numeric(arg(4)))){
        $form[arg(3)] = array (
             '#tree' => TRUE,
        );
        $form[arg(3)][] = array (
             '#type' => 'hidden',
             '#value' => arg(4),
        );
      }
      break;
  }
}


/*
 * Show table of available indicators based on query
 * with link to download all result files in zip.
 *
 * Module met DB query
 * Alleen query naar dat wat nodig is? indicatorname, topic, provider, version
 * Query per tabel
 * Maak een array van indicators/datasets/tabellen
 * Resultaat hoeft alleen lijst indicators te zijn.
 * Per resource een row
 * TODO theme function
 *
 * TODO If from combined: no indicator/country selected means all
 *
 * @param querystring
 *   ?year[min]=1500&year[max]=2013&country[]=12&country[]=13&country[]=14&indicator[]=50
 * @return
 *   link to /clio/datasets/download with same querystring
 */
function clio_search_results() {

  $query = drupal_get_query_parameters();
  if (empty($query)) {
    $query = drupal_get_query_parameters($_POST);
  }  
  // TODO beetje dubbelop hier

  $params = clio_search_get_querystring();  
  $indicators = $params['indicators'];
  
  $datasets = array();
  foreach ($indicators as $indicatortid) {
    $datasetnid = clio_search_get_dataset($indicatortid);
    if ($datasetnid) {
      $resourcenid = clio_search_get_resource($datasetnid);
      if ($resourcenid) {

        $result = clio_search_query($resourcenid, 1);
        if (count($result)) {

          $indicator = taxonomy_term_load($indicatortid);
          $topics = taxonomy_get_parents($indicatortid);
          $topic  = array_shift($topics);
          $dataset = node_load($datasetnid);
          // TODO Add Provider and Version from dataset.
          $datasets[$indicatortid] = array(
            'dataset' => $datasetnid,
            'resource' => $resourcenid,
            'indicator' => $indicator->name,
            'topic' => $topic->name,
          );
        }
      }
    }
  }
  
  if (count($datasets)) {
    $content = '<div class="searchresults"><table>';
    $content .= '<tr><th>Indicator</th><th>Topic</th><th>Provider</th><th>Version</th></tr>';
    foreach ($datasets as $tid => $info) {
      $content .= '<tr><td>' . $info['indicator'] . '</td><td>' . $info['topic'] . '</td>';
      $content .= '<td>IISG</td><td>1.0</td>';
      $content .= '</td></tr>';
    }
    $content .= '</table></div>';
    // TODO Create form, use POST.
    $content .= '<div class="search-submit">'. l('Ok', 'datasets/download', array('query' => $query)) . '</div>';
  }
  else {
    $content = "No results";
  }
  drupal_set_title("Search results");
  return $content;
}


/*
 * Select all datasets with selected indicators, 
 * get all resources in clio format, 
 * create result files based on resource files,
 * get list of all result file names and working paper files.
 * Then download zip with all result files directly, or show modal with license.
 *
 * querystring is:
 *   year[min]=1500&year[max]=2013&country[]=12&country[]=13&country[]=14&indicator[]=50
 */
function clio_search_download() { 

  $params = clio_search_get_querystring();  
  $indicators = $params['indicators'];
    
  // Create the result files and the list of files to be zipped.
  $files = array();
  // Create temporary files for the result set. pathnames? uri's? fids?
  // Managed or unmanaged?
  $datasets = array();
  // TODO drupal_mkdir($randomname), and use indicatornames as filenames;
  foreach ($indicators as $indicatortid) {
    $datasetnid = clio_search_get_dataset($indicatortid);
    if ($datasetnid) {
      $resourcenid = clio_search_get_resource($datasetnid);
      if ($resourcenid) {
        // TODO Are we sure the database table exists?
        $uri  = clio_search_create_result_file($resourcenid);
        if ($uri) {
          $files[] = drupal_realpath($uri);
        }
        $uri  = clio_search_get_working_paper($datasetnid); // public://wp.doc
        if ($uri) {
          $files[] = drupal_realpath($uri);
        }
      }
    }
  }

  if (count($files)) {
    // Combine all files in a zip.
    $zipfile = clio_search_create_zip($files);
    clio_search_transfer($zipfile);
    // TODO Werkt niet, na file_transfer stopt process. Hoeft niet want in tmp?
    file_unmanaged_delete($zipfile);
  }
}


/*
 * @param $tid
 *   The term ID of an indicator.
 * @return
 *   The nid of the dataset node referencing this indicator.
 */
function clio_search_get_dataset($tid) {
  $nids = taxonomy_select_nodes($tid, FALSE);
  if (count($nids)) {
    if (count($nids) == 1) {
      return $nids[0];
    }
    else {
      // What to do if there are several datasets connected to an indicator???
      return $nids[0];
    }
  }
  else {
    // This shouldn't happen at this stage.
    return;
  }        
}


/*
 * @param $nid
 *   The nid of a dataset node.
 * @return
 *   The nid of the row-based resource referenced by the dataset.
 */
function clio_search_get_resource($nid) {
  $node = node_load($nid);
  if (!(empty($node->field_resources))) {
    // The book children of the node. We need to find the generic file.
    foreach ($node->field_resources['und'] as $resource) {
      $r = node_load($resource['target_id']);
      // TODO This should be cleaner.
      if (preg_match('/(generic)/', $r->title)) {
        return $r->nid;
      }
    }
  }
  /*  
      // See Dataset.inc and dkan_dataset_api.inc

      $resources = array();
      foreach($node->field_resources['und'] as $key => $resource){
        $resources[] = $resource['target_id'];
      }
      $resources = node_load_multiple($resources);
      $row = new stdClass();
      $row->resources = dkan_open_data_build_dataset_resources($resources);
      $row->num_resources = count($resources);
  */
}


/*
 * @param $nid
 *   The nid of a dataset node.
 */
function clio_search_get_working_paper($nid) {
  $node = node_load($nid);
  // $file = drupal_realpath($uri); werkt niet voor remote files!
  $uri = '';
  if (isset($node->field_working_paper)) {
    $uri = $node->field_working_paper['und'][0]['uri'];
  }
  return $uri;
}


/*
 * @param $resource
 *   The nid of the resource
 *
 * TODO values 0 or empty?
 * TODO unset($data); or &$data
 */
function clio_search_create_result_file($resource, $xls = TRUE, $clioformat = TRUE) {
  $params = clio_search_get_querystring();
  $result = clio_search_db_query($resource, $params['years'], $params['countries']);
  if ($clioformat) {
    $rows = clio_search_convert_to_clio($result, $resource);
    $indicator = $rows[0][0];
  }
  else {
    $rows = clio_search_convert_to_rows($result, $resource);
    $indicator = $rows[5][0];
  }
  // TODO replace spaces in $indicator?
  if ($xls) {
    $file = clio_convert_save_as_xls($rows, $indicator);
  }
  else {
    $file = clio_search_convert_save_as_csv($rows, $indicator);
  }
  return $file->uri;


  // TODO let convert return a string instead of a file.
  // $contents = $csv;
  $temp_name = drupal_tempnam('temporary://', 'file'); 
  if (file_put_contents($temp_name, $contents) === FALSE) {
    drupal_set_message(t('The file could not be created.'), 'error');
    return FALSE;
  }
  return $temp_name;
}


/* 
 * Create zip archive, managed, temporary
 *
 * @param $files
 *  An array of file paths.
 * @return
 *  A zip file object.
 */
function clio_search_create_zip($files, $filename = NULL) {
  $path = drupal_get_path('module', 'clio_search') . '/pclzip';
  require_once $path . '/pclzip.lib.php';
  
  if (!($filename)) {
    $filename = drupal_tempnam('temporary://', 'data_');
    if (rename($filename, $filename . '.zip')) {
      $filename .= '.zip';
    }
  }
  $tmp_file = file_save_data('', $filename);
  $tmp_file->status = 0;
  $file = file_save($tmp_file);
  $archive = new PclZip(drupal_realpath($file->uri));
  $archive->add($files, PCLZIP_OPT_REMOVE_ALL_PATH);

  // TODO error check: what if file does not exist?
  // TODO file replace should work.
  
  // TODO move to public (/clio/zip), in case transfer won't work.
  // TODO delete source files: file_unmanaged_delete_recursive($path)
  // TODO unmanaged?
  // $ = file_unmanaged_save_data($zip , 'public://output.zip', FILE_EXISTS_REPLACE);
  return $file;
}


function clio_search_transfer($file) {
  // send the archive
//  module_invoke("pclzip", 'send_file', $filename);
  // This from download module.
  header("Content-Type: application/force-download");
  header('Content-Description: File Transfer');
  header('Content-Disposition: inline; filename=' . $file->filename);
  readfile(drupal_realpath($file->uri));
  exit();  
}
  
  
/**
 * Convert data from row-based to clio formatted data.
 *
 * @param $data
 *   Array of arrays, representing the spreadsheet cells.
 * @param $resource
 * @param $empty_years
 *   If TRUE columns for all years will be specified, even if there are no values.
 *
 * @return $rows
 *   Array of arrays in clio format.
 */
function clio_search_convert_to_clio($data, $resource, $empty_years = TRUE) {
  global $user;
  $countries = clio_get_countries();
  $rows = array();
  
  // Scan all rows and create array keyed by country code
  // as well as array of distinct years.
  $values = array();
  $years = ($empty_years) ? range(1500, CLIO_MAX_YEAR) : array();

  if ($datarow = $data->fetchAssoc()) {
    // Get indicator and unit from first row.
    $rows[] = array($datarow['indicator']);
    $rows[] = (isset($datarow['unit'])) ? array($datarow['unit']) : array();

    do {
      if (isset($datarow['value'])) {
        $values[$datarow['countrycode']][$datarow['year']] = $datarow['value'];
      } 
      else {
        $values[$datarow['countrycode']][$datarow['year']] = NULL;
      }
      if (!($empty_years)) {
        $years[$datarow['year']] = 1;
      }
    } while ($datarow = $data->fetchAssoc());
  }
  if (!($empty_years)) {
    // TODO sort earlier, in the view?
    ksort($years); 
    $years = array_keys($years);
  }

  // Create header row with year columns.
  $rows[] = array_merge(array('Code', 'Continent, Region, Country'), $years);

  // Create row for each country.
  foreach ($values as $countrycode => $yearvalue) {
    // Start with country code and name.
    $cells = array($countrycode, $countries[$countrycode]['name']);
    foreach ($years as $year) {
      // Add values per year.
      $cells[] = (isset($yearvalue[$year])) ? $yearvalue[$year] : '';
    }
    $rows[] = $cells;
  }
  return $rows;
}


function clio_search_convert_to_rows($data, $resource) {
  global $user;
  $countries = clio_get_countries();

  // Create header row with columns.
  $rows = array();

  if ($datarow = $data->fetchAssoc()) {

    $rows[] = array('Indicator', 'Unit', 'Country', 'Year', 'Value');
    // Get indicator and unit from first row.
    $indicator = $datarow['indicator'];
    $unit = (isset($datarow['unit'])) ? $datarow['unit'] : NULL;

    do {
      $value = (isset($datarow['value'])) ? $datarow['value'] : NULL;
      $rows[] = array($indicator, $unit, $datarow['countrycode'], $datarow['year'], $value);
    } while ($datarow = $data->fetchAssoc());
  }
  return $rows;
}


/*
 * Save as CSV, unmanaged, temporary.
 */
function clio_search_convert_save_as_csv($data, $prefix = 'clio') {
  global $user;
  // Create a temporary file.
  $tempdir = file_directory_temp();
  $filepath = drupal_tempnam($tempdir, $prefix .'-');
  if (rename($filepath, $filepath . '.csv')) {
    $filepath .= '.csv';
  }
  $filehandle = fopen($filepath, 'w+');
  $enclosure = '"';
  foreach ($data as $row) {
    fputcsv($filehandle, $row, CLIO_DELIMITER, $enclosure);
  }
  // Create a file object from temporary file.
  $filename = drupal_basename($filepath);
  $file = new stdClass();
  $file->fid = NULL;
  $file->uri = 'temporary://'. $filename;
  $file->filename = $filename;
  $file->filemime = 'text/csv';
  $file->uid = $user->uid;

  // TODO Without a save this check seems unnecessary.
  if (!empty($file)) {
//    drupal_set_message(t('Saved CSV file to destination %destination', array('%destination' => $filename)));
  }
  else {
    drupal_set_message(t('Failed to save CSV file'), 'error');
    return;
  }

  return $file;
}


/*
 * Save as Excel file, unmanaged, temporary.
 * Save as XLSX, as XLS allows no more than 256 columns.
 * TODO This takes 8 seconds per file!
 * TODO Use template?
 */
function clio_convert_save_as_xls($data, $prefix = 'clio') {
  global $user;
  module_load_include('inc', 'phpexcel');
  
  $tempdir = file_directory_temp();
  $path = drupal_tempnam($tempdir, $prefix .'-');
  if (rename($path, $path . '.xlsx')) {
    $path .= '.xlsx';
  }
  $headers = array();
  $options = array('format' => 'xlsx', 'ignore_headers' => TRUE);
  // TODO ignore_headers alleen als clio-format?
  $result = phpexcel_export($headers, $data, $path, $options);
  if ($result == PHPEXCEL_SUCCESS) {
    // Create a file object from temporary file.
    $filename = drupal_basename($path);
    $file = new stdClass();
    $file->fid = NULL;
    $file->uri = 'temporary://'. $filename;
    $file->filename = $filename;
    $file->filemime = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    $file->uid = $user->uid;
  }
  else {
    drupal_set_message(t("Error saving file as XLSX: ") . $result, 'error');
    return;
  }    
  if (!empty($file)) {
//    drupal_set_message(t('Saved file to destination %destination', array('%destination' => $filename)));
  }
  else {
    drupal_set_message(t('Failed to save XLSX file %destination', array('%destination' => $filename)), 'error');
    return;
  }

  return $file;
}





/*
 * Get years, countries and indicators from the querystring.
 * If no indicators are specified all available indicators will be returned.
 *
 * TODO input validation
 * TODO sort indicators in case of multiple parents?
 */
function clio_search_get_querystring() {
  $query = drupal_get_query_parameters();
  if (empty($query)) {
    $query = drupal_get_query_parameters($_POST);
  }
  $years = isset($query['year']) ? $query['year'] : array();
  $countries = isset($query['country']) ? $query['country'] : array();
  if (isset($query['indicator'])) {
    $indicators = $query['indicator'];
  }
  else {
    // All indicators.
    $indicators = array();
    $vocab = taxonomy_vocabulary_machine_name_load('indicators');
    $topics = taxonomy_get_tree($vocab->vid, 0, 1);
    foreach ($topics as $topic) {
      $children = taxonomy_get_children($topic->tid);
      foreach ($children as $child) {
        $indicators[] = $child->tid;
      }
    }
    $indicators = array_unique($indicators);
  }
  return array('years' => $years, 'countries' => $countries, 'indicators' => $indicators);
}


/*
 * Add a where clause to the query based on the query string.
 * TODO match whole viewname
 * TODO add mapping to indicatortid and countrytid here, instead of in convert
 * We need just a subset: indicator, unit, countrycode, year, value (indicatortid, countrytid)
 */
function clio_search_views_query_alter(&$view, &$query) {
  if (preg_match('/feeds_datastore_dkan_file_/', $view->name) && ($view->current_display == 'page_1')) {
    $params = clio_search_get_querystring();
    $years = $params['years'];
    $countries = $params['countries'];
    if (count($years)) {
      if (!empty($years['min'])) {
        $view->query->add_where(0, db_and()->condition($view->name . '.year', $years['min'], '>='));
      }
      if (!empty($years['max'])) {
        $view->query->add_where(0, db_and()->condition($view->name . '.year', $years['max'], '<='));
      }
    }
    if (count($countries)) {
      $view->query->add_where(0, db_and()->condition($view->name . '.countrytid', $countries));
    }
  }
}


function clio_search_views_pre_build(&$view) {
  if (preg_match('/feeds_datastore_dkan_file_/', $view->name) && ($view->current_display == 'page_1')) {
    unset($view->field['indicatortid']);
    unset($view->field['countrytid']);
    unset($view->field['timestamp']);
    unset($view->field['feeds_entity_id']);
    unset($view->field['feeds_flatstore_entry_id']);
  }
}


/*
 * TODO This should be paged/batched. See views_data_export.
 */
function clio_search_query($resourcenid, $items = 10000) {
  $tablename = 'dkan_file_' . $resourcenid;
  $viewname  = 'feeds_datastore_' . $tablename;
  $view = views_get_view($viewname);
  $view->set_display('page_1');
  $view->set_items_per_page($items); // Return all if 0.
  $view->pre_execute();
  $view->execute();
  return $view->result;
}


/*
 * Alternative, direct database query implementation.
 */
function clio_search_db_query($resourcenid, $years = array(), $countries = array(), $items = 0) {
  $tablename = 'dkan_file_' . $resourcenid;
  $viewname  = 'feeds_datastore_' . $tablename;

  // TODO add mapping to indicatortid and countrytid here, instead of in convert
  $query = db_select($viewname, 't')
    ->fields('t', array('indicator', 'unit', 'value', 'countrycode', 'year'));
  if ($items) {
    $query->range(0, $items);
  }
  if (count($years)) {
    if (!empty($years['min'])) {
      $query->condition('t.year', $years['min'], '>=');
    }
    if (!empty($years['max'])) {
      $query->condition('t.year', $years['max'], '<=');
    }
    if (!empty($years['eq'])) {
      $query->condition('t.year', $years['eq'], '=');
    }
  }
  if (count($countries)) {
    $query->condition('t.countrytid', $countries, 'IN');
  }
  $result = $query->execute();
  return $result;
}


/*
 *
 */
function clio_search_taxonomy_get_leaves($machine_name, $parent = 0) {
  $v = taxonomy_vocabulary_machine_name_load($machine_name);
  $terms = taxonomy_get_tree($v->vid, $parent);
  foreach ($terms as $term) {
    if (!(taxonomy_get_children($term->tid, $v->vid))) {
      $options[$term->tid] = $term->name;
    }
  }
  asort($options);
  return $options;
}


