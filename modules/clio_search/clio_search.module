<?php

/*
 * Views to query the stored datasets.
 */
 /*
function clio_search_views_default_views() {
  $views = array();
  $path = drupal_get_path('module', 'clio_search') . '/views';
  $files = drupal_system_listing('/.*\.inc$/', $path, 'name', 0);
  foreach($files as $file) {
    include_once $path . '/' . $file->filename;
    $views[$view->name] = $view;
  }
  return $views;
} 
*/

/**
 * Implements hook_menu().
 */
function clio_search_menu() {
  $items = array();
  $items['datasets'] = array(
    'title' => 'Datasets',
    'page callback' => 'datasets_intro',
    'access arguments' => array('search datasets'),
    'expanded' => TRUE,
  );
  $items['datasets/countries'] = array(
    'page callback'    => 'clio_search_list',
    'page arguments'   => array(1),
    'access arguments' => array('search datasets'),
    'type'             => MENU_CALLBACK,
    'weight' => 10,
  );
  $items['datasets/topics'] = array(
    'page callback'    => 'clio_search_list',
    'page arguments'   => array(1),
    'access arguments' => array('search datasets'),
    'type'             => MENU_CALLBACK,
    'weight' => 11,
  );
  $items['datasets/indicators'] = array(
    'page callback'    => 'clio_search_list',
    'page arguments'   => array(1),
    'access arguments' => array('search datasets'),
    'type'             => MENU_CALLBACK,
    'weight' => 12,
  );
  $items['datasets/combined'] = array(
    'page callback'    => 'clio_search_select',
    'page arguments'   => array(1),
    'access arguments' => array('search datasets'),
    'type'             => MENU_CALLBACK,
    'weight' => 13,
  );
  $items['datasets/select/%/%'] = array(
    'page callback'    => 'clio_search_select',
    'page arguments'   => array(2, 3),
    'access arguments' => array('search datasets'),
    'type'             => MENU_CALLBACK,
  );
  $items['datasets/searchresults'] = array(
    'page callback'    => 'clio_search_results',
    'access arguments' => array('search datasets'),
    'type'             => MENU_CALLBACK,
  );
  $items['datasets/transfer'] = array(
    'page callback'    => 'clio_search_transfer',
    'page arguments'   => array(2),
    'access arguments' => array('download datasets'),
    'type'             => MENU_CALLBACK,
  );
  return $items;
}


/**
 * Implements hook_permission().
 */
function clio_search_permission() {
  return array(
    'search datasets' => array(
      'title' => t('Search and filter datasets'),
    ),
    'download datasets' => array(
      'title' => t('Download search results as zip file'),
    ),
  );
}

function datasets_intro() {
  drupal_goto('datasets/indicators');
}

/*
 * Show a list of countries, indicators or topics.
 * Link to a page to further filter results.
 *
 * Feature clio_indicators_and_countries_views bevat views van termen, 
 * o.b.v. content-type datapoint, met URL rewrite.
 *
 * @param $vocab
 *   Vocabulary name
 * @return
 *   Themed list with links e.g. /datasets/select/country/12
 */
function clio_search_list($vocab) {
  switch ($vocab) {
    case 'countries':
      drupal_set_title('Countries');
      $output = clio_search_list_terms('countries', 'country');
      break;
    case 'topics':
      drupal_set_title('Topics');
      $output = views_embed_view('indicators', 'page_1');
      break;
    case 'indicators':
    default:
      drupal_set_title('Indicators');
      $output = views_embed_view('indicators', 'page');
      break;
  }
  return $output;
}


/*
 * Show a list of terms, grouped by first letter.
 * TODO Use theme_item_list, adjust for topics and indicators.
 *
 * @param $vocab_name
 *   Vocabulary name
 * @return
 *   Themed list with links e.g. /datasets/select/country/12
 */
function clio_search_list_terms($vocab_name, $path) {
  $term_list = clio_search_taxonomy_get_leaves($vocab_name);
  $output = '<ul class="country-list">';
  $char = 'A';
  // Hmmm.
  $output .= '<li class="startletter">' . $char . '</li><ul>';          
  foreach ($term_list as $tid => $name) {
    if (mb_substr($name, 0, 1) != $char) {
      $char = mb_substr($name, 0, 1);
      $output .= '</ul><li class="startletter">' . $char . '</li><ul>';          
    }
    $output .= '<li class="country"><a href="/datasets/select/' . $path . '/' . $tid . '">' . $name . '</a></li>';
  }
  $output .= '</ul></ul>';
  return $output;
}


/*
 * Show a form with select boxes or list of checkboxes (combined, tree view)
 * to select countries, indicators and years.
 *
 * Feature clio_datapoint_and_data_views bevat o.a. view met exposed filters + argument
 * Year (from, to), indicators, countries
 *
 * @param $vocab
 *   Vocabulary name
 * @param $tid
 *   Term ID
 * @return
 *   Themed list with links, e.g.
 *   /datasets/searchresults?year[min]=1500&year[max]=1800&indicator[]=113&indicator[]=304&indicator[]=83
 */
function clio_search_select($vocab = 'combined', $tid = NULL) {
  $term = (arg(3) && is_numeric(arg(3))) ? taxonomy_term_load(arg(3)) : NULL;
  switch ($vocab) {
    case 'country':
      $title = ($term) ? $term->name : 'Select';
      drupal_set_title($title);
      $output = drupal_get_form('clio_search_select_form');
      break;
    case 'indicator':
      $title = ($term) ? $term->name : 'Select';
      drupal_set_title($title);
      $output = drupal_get_form('clio_search_select_form');
      break;
    case 'topic':
      $title = ($term) ? $term->name : 'Select';
      drupal_set_title($title);
      $output = drupal_get_form('clio_search_select_form');
      break;
    case 'combined':
    default:
      drupal_set_title('Combined search');
      $output = views_embed_view('data', 'page_4');
      $output .= clio_search_select_message();
      break;
  }
  return $output;
}


/*
 * Show a filter form with years and countries and/or indicators,
 * depending on the arguments.
 */
function clio_search_select_form($form, &$form_state) {
  $form['#action'] = url('datasets/searchresults');
  $form['year'] = array (
    '#tree' => TRUE,
    '#title' => t('Time period'),
  );
  $form['year']['min'] = array (
    '#type' => 'textfield',
    '#title' => t('from'),
    '#size' => 4,
    '#default_value' => 1500,
  );
  $form['year']['max'] = array (
    '#type' => 'textfield',
    '#title' => t('to'),
    '#size' => 4,
    '#default_value' => CLIO_MAX_YEAR,
  );

  if (((arg(2) == 'country') || (arg(2) == 'indicator')) && (is_numeric(arg(3)))) {
    $form[arg(2)] = array (
         '#tree' => TRUE,
    );
    $form[arg(2)][] = array (
         '#type' => 'hidden',
         '#value' => arg(3),
    );
  }
  
  if ((arg(2) == 'topic') && (is_numeric(arg(3)))) {
    $form[arg(2)] = array (
         '#type' => 'hidden',
         '#value' => arg(3),
    );
  }

  if (((arg(2) == 'country') || (arg(2) == 'topic')) && (is_numeric(arg(3)))) {
    $parent = (arg(2) == 'topic') ? arg(3) : 0;
  
    $form['indicator'] = array(
      '#type' => 'select',
      '#title' => t('Indicators'),
      '#options' => clio_search_taxonomy_get_leaves('indicators', $parent),
      '#multiple' => TRUE,
      '#size' => 14,
    );
  }
  
  if ((arg(2) == 'indicator') || (arg(2) == 'topic')) {
    $form['country'] = array(
      '#type' => 'select',
      '#title' => t('Countries'),
      '#options' => clio_search_taxonomy_get_leaves('countries'),
      '#multiple' => TRUE,
      '#size' => 14,
    );
  }

  $form['message'] = array(
    '#prefix' => '<div class="select-message">(',
    '#markup' => t('Leave blank for all available data'),
    '#suffix' => ')</div>',
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('OK'),
  );

  return $form;  
}


/*
 * Save selected country or indicator between requests.
 * Redirect exposed filter form to results function.
 */
function clio_search_form_views_exposed_form_alter(&$form, &$form_state, $form_id) {
  switch ($form['#id'])  {
    case 'views-exposed-form-data-page-1':
    case 'views-exposed-form-data-page-2':
    case 'views-exposed-form-data-page-3':
    case 'views-exposed-form-data-page-4':
      $form['#action'] = url('datasets/searchresults');
      if (((arg(3) == 'country') || (arg(3) == 'indicator')) && (is_numeric(arg(4)))){
        $form[arg(3)] = array (
             '#tree' => TRUE,
        );
        $form[arg(3)][] = array (
             '#type' => 'hidden',
             '#value' => arg(4),
        );
      }
      break;
  }
}


/*
 * Show table of available indicators/datasets based on query
 * with button to download all result files in zip.
 *
 * @param querystring
 *   E.g. year[min]=1500&year[max]=2013&country[]=12&country[]=13&country[]=14&indicator[]=50
 * @return
 *   link to /datasets/download with same querystring
 */
function clio_search_results() {
  $params = clio_search_get_params();  
  $indicators = $params['indicator'];
  
  $datasets = array();
  foreach ($indicators as $indicatortid) {
    $datasetnid = clio_search_get_dataset($indicatortid);
    if ($datasetnid) {
      $resourcenid = clio_search_get_resource($datasetnid);
      if ($resourcenid) {

        $result = clio_search_db_query($resourcenid, $params['year'], $params['country'], 1);
        if ($result->rowCount()) {

          $indicator = taxonomy_term_load($indicatortid);
          $topics = taxonomy_get_parents($indicatortid);
          $topic  = array_shift($topics);
          $dataset = node_load($datasetnid);
          // TODO Add Provider and Version from dataset.
          $datasets[$indicatortid] = array(
            'dataset' => $datasetnid,
            'resource' => $resourcenid,
            'indicator' => $indicator->name,
            'topic' => $topic->name,
          );
        }
      }
    }
  }
  
  if (count($datasets)) {
    // The table with results.
    $header = array(t('Indicator'), t('Topic'), t('Provider'), t('Version'));
    $rows = array();
    foreach ($datasets as $tid => $info) {
      $rows[] = array($info['indicator'], $info['topic'], 'IISG', '1.0');
    }
    $content = '<div class="searchresults">';
    $content .= theme('table', array('header' => $header, 'rows' => $rows, 'sticky' => FALSE));
    $content .= '</div>';
    
    // The download button.
    $downloadform = drupal_get_form('clio_search_download_form', $params);
    $content .= drupal_render($downloadform);
  }
  else {
    $content = "No results";
  }
  drupal_set_title("Search results");
  return $content;
}


/*
 *  Create download button.
 *
 * @param $params
 *   The search parameters (year, topic, indicator, country).
 */
function clio_search_download_form($form, &$form_state, $params) {
  foreach ($params as $field => $values) {
    $form[$field] = array(
      '#type' => 'value',
      '#tree' => TRUE,
    );
    foreach ($values as $key => $value) {
      $form[$field][$key] = array(
        '#type' => 'hidden', // Cannot be value as we need it in the params.
        '#value' => $value,
      );
    }
  }
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Ok'),
    '#prefix' => '<div class="search-submit">',
    '#suffix' => '</div>',
  );
  return $form;
}


/*
 * Select all datasets with selected indicators, 
 * get all resources in clio format, 
 * create result files based on resource files,
 * get list of all result file names and working paper files.
 * Then download zip with all result files directly, or show modal with license.
 *
 * querystring is:
 *   year[min]=1500&year[max]=2013&country[]=12&country[]=13&country[]=14&indicator[]=50
 */
function clio_search_download_form_submit() { 
  $params = clio_search_get_params();  
  $indicators = $params['indicator'];

  $files = array(); // The list of files to be created.
  foreach ($indicators as $indicatortid) {
    $datasetnid = clio_search_get_dataset($indicatortid);
    if ($datasetnid) {
      $resourcenid = clio_search_get_resource($datasetnid);
      if ($resourcenid) {
        $files[] = array('resource' => $resourcenid, 'dataset' => $datasetnid);
      }
    }
  }

  if (!empty($files)) {
    // Create a temporary directory for the resulting zip file.
    $dir = 'zip' . mt_rand(0, 9999999);
    drupal_mkdir('public://clio/' . $dir);
    // TODO Store in separate database table instead of variable.
    $oldfiles = variable_get('clio_search_zipfiles', array());
    $oldfiles[$dir] = time();
    variable_set('clio_search_zipfiles', $oldfiles);
    
    $batch = array(
      'operations' => array(
        array('clio_search_create_result_files', array($params, $files, $dir, TRUE, TRUE)),
        ),
      'finished' => 'clio_search_finished',
      'title' => t('Creating download file'),
      'init_message' => t('Starting file creation.'),
      'progress_message' => t('Processed @current out of @total tasks.'),
      'error_message' => t('Download file creation has encountered an error.'),
    );
    batch_set($batch);
    batch_process('datasets/transfer/' . $dir);
  }
}


/*
 * Delete expired zip file directories.
 */
function clio_statplanet_cron() {
  $oldfiles = variable_get('clio_search_zipfiles', array());
  $filesdir = variable_get('file_public_path', conf_path() . '/files');
  foreach ($oldfiles as $dir => $time) {
    if (time() - $time > 86400) {
      // Delete after one day.
      if (file_unmanaged_delete_recursive($filesdir . '/clio/' . $dir)) {
        unset($oldfiles[$dir]);
      }
      else {
        watchdog('clio_search', 'Could not delete directory %dir', array('%dir' => $dir), WATCHDOG_ERROR);
      }
    }
  }
  variable_set('clio_search_zipfiles', $oldfiles);
}


/*
 * @param $tid
 *   The term ID of an indicator.
 * @return
 *   The nid of the dataset node referencing this indicator.
 */
function clio_search_get_dataset($tid) {
  $nids = taxonomy_select_nodes($tid, FALSE);
  if (count($nids)) {
    if (count($nids) == 1) {
      return $nids[0];
    }
    else {
      // TODO What to do if there are several datasets linked to one indicator?
      return $nids[0];
    }
  }
  else {
    // This shouldn't happen at this stage.
    return;
  }        
}


/*
 * @param $nid
 *   The nid of a dataset node.
 * @return
 *   The nid of the row-based resource referenced by the dataset.
 */
function clio_search_get_resource($nid) {
  $node = node_load($nid);
  if (!(empty($node->field_resources))) {
    // The book children of the node. We need to find the converted file.
    foreach ($node->field_resources['und'] as $resource) {
      $r = node_load($resource['target_id']);
      // TODO This should be cleaner.
      if (preg_match('/(generic)/', $r->title)) {
        return $r->nid;
      }
    }
  }
  /*  
      // See Dataset.inc and dkan_dataset_api.inc

      $resources = array();
      foreach($node->field_resources['und'] as $key => $resource){
        $resources[] = $resource['target_id'];
      }
      $resources = node_load_multiple($resources);
      $row = new stdClass();
      $row->resources = dkan_open_data_build_dataset_resources($resources);
      $row->num_resources = count($resources);
  */
}


/*
 * @param $nid
 *   The nid of a dataset node.
 * @return
 *   The $uri of the working paper.
 */
function clio_search_get_working_paper($nid) {
  $node = node_load($nid);
  $uri = '';
  if (isset($node->field_working_paper)) {
    $uri = $node->field_working_paper['und'][0]['uri'];
  }
  return $uri;
}


/*
 * Process one resource file and working paper per batch step.
 *
 * @param $params
 *   Array with query parameters.
 * @param $files
 *   Array with the list of files to create.
 * @param $dir
 *   Directory to save the files in.
 * @param $xls
 *   Boolean indicating whether to save as CSV or XLSX.
 * @param $clioformat
 *   Boolean indicating whether to save in row-based or clio format.
 */
function clio_search_create_result_files($params, $files, $dir, $xls = TRUE, $clioformat = TRUE,  &$context) {

  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_file'] = 0;
    $context['sandbox']['max'] = count($files);
    $context['results']['dir'] = $dir;
  }
  
  $uri1 = clio_search_create_result_file($params, $files[$context['sandbox']['current_file']]['resource'], $dir, $xls, $clioformat);
  if ($uri1) {
    $context['results']['files'][] = drupal_realpath($uri1);
    $uri2 = clio_search_get_working_paper($files[$context['sandbox']['current_file']]['dataset'], $dir);
    if ($uri2) {
      // N.B. drupal_realpath($uri) werkt niet voor remote files!
      $context['results']['files'][] = drupal_realpath($uri2);
    }
  }
  
  // Update progress information.
  $context['sandbox']['progress']++;
  $context['sandbox']['current_file']++;
  $context['message'] = t('Now processing %file', array('%file' => drupal_basename($uri1, 'xlsx')));

  // Inform the batch engine that we are not finished,
  // and provide an estimation of the completion level we reached.
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}


/*
 * Based on a resource and the query, create a result file.
 *
 * @param $params
 *   Array with query parameters.
 * @param $resource
 *   The nid of the resource.
 * @param $dir
 *   Directory to save the files in.
 * @param $xls
 *   Boolean indicating whether to save as CSV or XLSX.
 * @param $clioformat
 *   Boolean indicatting whether to save in row-based or clio format.
 */
function clio_search_create_result_file($params, $resource, $dir, $xls = TRUE, $clioformat = TRUE) {
  $result = clio_search_db_query($resource, $params['year'], $params['country']);
  if ($result->rowCount()) {
    if ($clioformat) {
      $allcountries = empty($params['country']);
      $rows = clio_search_convert_to_clio($result, $resource, $allcountries);
      $indicator = $rows[0][0];
    }
    else {
      $rows = clio_search_convert_to_rows($result, $resource);
      $indicator = $rows[5][0];
    }
    // Note: spaces in $indicator could be replaced to create safer filename.
    if ($xls) {
      $file = clio_convert_save_as_xls($rows, $indicator, $dir);
    }
    else {
      $file = clio_search_convert_save_as_csv($rows, $indicator, $dir);
    }
    if ($file) {
      return $file->uri;
    }
    else {
      return;
    }
  }
  else {
    return;
  }

  // Note: we could let convert return a CSV string instead of a file.
  $temp_name = drupal_tempnam('temporary://', 'file'); 
  if (file_put_contents($temp_name, $contents) === FALSE) {
    drupal_set_message(t('The file could not be created.'), 'error');
    return FALSE;
  }
  return $temp_name;
}


/**
* Batch 'finished' callback
*/
function clio_search_finished($success, $results, $operations) {
  if ($success) {
    if (count($results['files'])) {
      // Combine all files in a zip.
      $zipfile = clio_search_create_zip($results['files'], $results['dir']);
    }
  }
  else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    $message = t('An error occurred while processing %error_operation with arguments: @arguments', array('%error_operation' => $error_operation[0], '@arguments' => print_r($error_operation[1], TRUE)));
    drupal_set_message($message, 'error');
  }
}


/* 
 * Create zip archive, managed, temporary
 *
 * @param $files
 *  An array of file paths.
 * @param $dir
 *  A subdirectory of the Clio files directory in which to place the zip file.
 * @return
 *  A zip file uri.
 */
function clio_search_create_zip($files, $dir = '') {
  $path = drupal_get_path('module', 'clio_search') . '/pclzip';
  require_once $path . '/pclzip.lib.php';

  if ($dir) {
    $filename = 'public://clio/' . $dir . '/data.zip';
  }
  else {
    $filename = drupal_tempnam('temporary://', 'data_');
    if (rename($filename, $filename . '.zip')) {
      $filename .= '.zip';
    }
  }
  $filepath = drupal_realpath($filename);
  $archive = new PclZip($filepath);
  $archive->add($files, PCLZIP_OPT_REMOVE_ALL_PATH);
  if (file_exists($filepath)) {  
    return $filename;
  }
}


/*
 * Transfer the created zip file to the client.
 *
 * @param $dir
 *  A subdirectory of the Clio files directory in which the zip file is available.
 */
function clio_search_transfer($dir) {
  $file = variable_get('file_public_path', conf_path() . '/files') . '/clio/' . $dir . '/data.zip';
  if (file_exists(drupal_realpath($file))) {
    drupal_add_js('jQuery(document).ready(function () { window.location.assign(\'/' . $file . '\'); });',
      array('type' => 'inline', 'scope' => 'footer')
    );
    return '<p>Problems with the download? Please use this <a href="javascript:void(0);" name="Download dataset" title="Dataset" onClick=window.open("/' . $file . '","Dataset","width=0,height=0,0,status=0")>direct link</a>.</p>';
  }
  else {
    // The error message from the batch finished callback should be available as well.
    drupal_set_message('An error occurred while creating the download file.', 'error');
    drupal_goto('/datasets');
  }
}
  

/**
 * Convert data from row-based to clio formatted data.
 *
 * @param $data
 *   Array of arrays, representing the spreadsheet cells.
 * @param $resource
 *   The resource nid.
 * @param $empty_years
 *   If TRUE columns for all years will be specified, even if there are no values.
 * @param $allcountries
 *   Boolean.
 *
 * @return $rows
 *   Array of arrays in clio format.
 */
function clio_search_convert_to_clio($data, $resource, $allcountries = FALSE, $empty_years = FALSE) {
  global $user;
  $countries = clio_get_countries();
  $rows = array();
  
  // Scan all rows and create array keyed by country code
  // as well as array of distinct years.
  $values = array();
  $years = ($empty_years) ? range(1500, CLIO_MAX_YEAR) : array();

  if ($datarow = $data->fetchAssoc()) {
    // Get indicator and unit from first row.
    $rows[] = array($datarow['indicator']);
    $rows[] = (isset($datarow['unit'])) ? array($datarow['unit']) : array();

    do {
      if (isset($datarow['value'])) {
        $values[$datarow['countrycode']][$datarow['year']] = $datarow['value'];
      } 
      else {
        $values[$datarow['countrycode']][$datarow['year']] = NULL;
      }
      if (!($empty_years)) {
        $years[$datarow['year']] = 1;
      }
    } while ($datarow = $data->fetchAssoc());
  }
  if (!($empty_years)) {
    // ksort($years); Already sorted in db query.
    $years = array_keys($years);
  }

  // Create header row with year columns.
  $rows[] = array_merge(array('Code', 'Continent, Region, Country'), $years);

  // TODO if ($allcountries) { foreach ($countries as $countrycode => $fields) }
  // TODO else { sort? on what? }
  // Create row for each country.
  foreach ($values as $countrycode => $yearvalue) {
    // Start with country code and name.
    $cells = array($countrycode, $countries[$countrycode]['name']);
    foreach ($years as $year) {
      // Add values per year.
      $cells[] = (isset($yearvalue[$year])) ? $yearvalue[$year] : '';
    }
    $rows[] = $cells;
  }
  return $rows;
}


/**
 * Provide data in row-based format with header.
 *
 * @param $data
 *   Array of arrays, representing the spreadsheet cells.
 * @param $resource
 *   The resource nid.
 *
 * @return $rows
 *   Array of arrays.
 */
function clio_search_convert_to_rows($data, $resource) {
  global $user;
  $countries = clio_get_countries();

  // Create header row with columns.
  $rows = array();

  if ($datarow = $data->fetchAssoc()) {

    $rows[] = array('Indicator', 'Unit', 'Country', 'Year', 'Value');
    // Get indicator and unit from first row.
    $indicator = $datarow['indicator'];
    $unit = (isset($datarow['unit'])) ? $datarow['unit'] : NULL;

    do {
      $value = (isset($datarow['value'])) ? $datarow['value'] : NULL;
      $rows[] = array($indicator, $unit, $datarow['countrycode'], $datarow['year'], $value);
    } while ($datarow = $data->fetchAssoc());
  }
  return $rows;
}


/*
 * Save data as CSV, unmanaged, temporary.
 * TODO Use $dir
 * 
 * @param $data
 *   Array of arrays, representing the spreadsheet cells.
 *
 * @return
 *   A file object.
 */
function clio_search_convert_save_as_csv($data, $prefix = 'clio', $dir = '') {
  global $user;
  // Create a temporary file.
  $tempdir = file_directory_temp();
  $filepath = drupal_tempnam($tempdir, $prefix .'-');
  if (rename($filepath, $filepath . '.csv')) {
    $filepath .= '.csv';
  }
  $filehandle = fopen($filepath, 'w+');
  $enclosure = '"';
  foreach ($data as $row) {
    fputcsv($filehandle, $row, CLIO_DELIMITER, $enclosure);
  }
  // Create a file object from temporary file.
  $filename = drupal_basename($filepath);
  $file = new stdClass();
  $file->fid = NULL;
  $file->uri = 'temporary://'. $filename;
  $file->filename = $filename;
  $file->filemime = 'text/csv';
  $file->uid = $user->uid;

  return $file;
}


/*
 * Save as Excel file, unmanaged, temporary.
 * Save as XLSX, as XLS allows no more than 256 columns.
 * TODO Fix prefix name
 * 
 * @param $data
 *   Array of arrays, representing the spreadsheet cells.
 *
 * @return
 *   A file object.
 */
function clio_convert_save_as_xls($data, $prefix, $dir = '') {
  global $user;
  module_load_include('inc', 'phpexcel');
  
  if ($prefix) {
    // prefix = indicatorname
    $filesdir = variable_get('file_public_path', conf_path() . '/files');
    $filename = $prefix . '.xlsx';
    $path = $filesdir . '/clio/' . $dir . '/' . $filename;
    $uri = 'public://clio/' . $dir . '/' . $filename;
  }
  else {
    $tempdir = file_directory_temp();
    $path = drupal_tempnam($tempdir . '/' . $dir, $prefix .'-');
    if (rename($path, $path . '.xlsx')) {
      $path .= '.xlsx';
    }
    $filename = drupal_basename($path);
    $uri = 'temporary://'. $filename;
  }

  $headers = array();
  $template = drupal_get_path('module', 'clio_search') . '/template/clio-template.xlsx';
  $options = array('format' => 'xlsx', 'ignore_headers' => TRUE, 'template' => $template);
  // TODO ignore_headers only if clio-format?
  $result = phpexcel_export($headers, $data, $path, $options);
  if ($result == PHPEXCEL_SUCCESS) {
    // Create a file object from temporary file.
    $filename = $filename;
    $file = new stdClass();
    $file->fid = NULL;
    $file->uri = $uri;
    $file->filename = $filename;
    $file->filemime = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    $file->uid = $user->uid;
  }
  else {
    drupal_set_message(t("Error saving file as XLSX, error code: ") . $result, 'error');
    return;
  }    
  if (empty($file)) {
    drupal_set_message(t('Failed to save XLSX file %destination', array('%destination' => $filename)), 'error');
    return;
  }
  return $file;
}


/*
 * Get years, countries and indicators from the querystring.
 * Make sure all values are numeric.
 * If no indicators are specified all available indicators will be returned.
 *
 * TODO Sort indicators in case of multiple parents?
 *
 * @return
 *   An array of arrays containing year, country and indicator.
 */
function clio_search_get_params() {
  $query = drupal_get_query_parameters();
  if (empty($query)) {
    $query = drupal_get_query_parameters($_POST);
  }
  $years = isset($query['year']) ? array_filter($query['year'], 'is_numeric') : array();
  $countries = isset($query['country']) ? array_filter($query['country'], 'is_numeric') : array();
  if (isset($query['indicator'])) {
    $indicators = array_filter($query['indicator'], 'is_numeric');
  }
  else {
    if (isset($query['topic']) && is_numeric($query['topic'])) {
      $indicators = array();
      $children = taxonomy_get_children($query['topic']);
      foreach ($children as $child) {
        $indicators[] = $child->tid;
      }
    }
    else {
    // All indicators.
      $indicators = array();
      $vocab = taxonomy_vocabulary_machine_name_load('indicators');
      $topics = taxonomy_get_tree($vocab->vid, 0, 1);
      foreach ($topics as $topic) {
        $children = taxonomy_get_children($topic->tid);
        foreach ($children as $child) {
          $indicators[] = $child->tid;
        }
      }
      $indicators = array_unique($indicators);
    }
  }
  return array('year' => $years, 'country' => $countries, 'indicator' => $indicators);
}


/*
 * Add a where clause to the query based on the query string.
 * TODO Do we still need this?
 * TODO match whole viewname
 * TODO add mapping to indicatortid and countrytid here, instead of in convert
 * We need just a subset: indicator, unit, countrycode, year, value (indicatortid, countrytid)
 */
function clio_search_views_query_alter(&$view, &$query) {
  if (preg_match('/feeds_datastore_dkan_file_/', $view->name) && ($view->current_display == 'page_1')) {
    $params = clio_search_get_params();
    $years = $params['year'];
    $countries = $params['country'];
    if (count($years)) {
      if (!empty($years['min'])) {
        $view->query->add_where(0, db_and()->condition($view->name . '.year', $years['min'], '>='));
      }
      if (!empty($years['max'])) {
        $view->query->add_where(0, db_and()->condition($view->name . '.year', $years['max'], '<='));
      }
    }
    if (count($countries)) {
      $view->query->add_where(0, db_and()->condition($view->name . '.countrytid', $countries));
    }
  }
}


/*
 * Return anything except these fields.
 */
function clio_search_views_pre_build(&$view) {
  if (preg_match('/feeds_datastore_dkan_file_/', $view->name) && ($view->current_display == 'page_1')) {
    unset($view->field['indicatortid']);
    unset($view->field['countrytid']);
    unset($view->field['timestamp']);
    unset($view->field['feeds_entity_id']);
    unset($view->field['feeds_flatstore_entry_id']);
  }
}


/*
 * Query the database table for the resource.
 *
 * @param $resourcenid
 * @param $years
 * @param $countries
 * @param $items
 *   The number of items to return.
 *
 * @return
 *   A database result set.
 */
function clio_search_db_query($resourcenid, $years = array(), $countries = array(), $items = 0) {
  $tablename = 'feeds_datastore_dkan_file_' . $resourcenid;

  global $databases;
  $db = $databases['default']['default']['database'];
  $exists = db_query('SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE table_schema = :db AND table_name = :table', array(':db' => $db, ':table' => $tablename))->fetchField();
  if ($exists == FALSE) {
    watchdog('clio_search', t("Table does not exists: %table"), array('%table' => $tablename), WATCHDOG_WARNING);
    return;
  }

  // TODO add mapping to indicatortid and countrytid here, instead of in convert
  $query = db_select($tablename, 't')
    ->fields('t', array('indicator', 'unit', 'value', 'countrycode', 'year'));
  if ($items) {
    $query->range(0, $items);
  }
  if (count($years)) {
    if (!empty($years['min'])) {
      $query->condition('t.year', $years['min'], '>=');
    }
    if (!empty($years['max'])) {
      $query->condition('t.year', $years['max'], '<=');
    }
    if (!empty($years['eq'])) {
      $query->condition('t.year', $years['eq'], '=');
    }
  }
  if (count($countries)) {
    $query->condition('t.countrytid', $countries, 'IN');
  }
  $query->orderBy('t.year', 'ASC');
  $result = $query->execute();
  return $result;
}


/*
 * Get only the leaves of a term tree.
 *
 * @param $machine_name
 *   A vocabulary machine name.
 * @param $parent
 *   The parent tid to start from.
 *
 * @return
 *   An array of term names keyed by tid, sorted by name.
 */
function clio_search_taxonomy_get_leaves($machine_name, $parent = 0) {
  $v = taxonomy_vocabulary_machine_name_load($machine_name);
  $terms = taxonomy_get_tree($v->vid, $parent);
  foreach ($terms as $term) {
    if (!(taxonomy_get_children($term->tid, $v->vid))) {
      $options[$term->tid] = $term->name;
    }
  }
  asort($options);
  return $options;
}


