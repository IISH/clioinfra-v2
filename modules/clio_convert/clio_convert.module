<?php
/**
 * @file
 * Convert clio CSV to row-based CSV
 */


/**
 * Implementation of function array_column() for PHP versions < 5.5.
 */
include('src/array_column.php');
 

/**
 * Implements hook_menu().
 */
function clio_convert_menu() {
  // Add tab to resource.
  $items['node/%node/clio'] = array(
    'title' => 'Convert',
    'page callback' => 'clio_convert_page',
    'page arguments' => array(1),
    'access callback' => 'clio_convert_convert_access',
    'access arguments' => array(1),
    'weight' => '14', // Before datastore tab.
    'type' => MENU_LOCAL_TASK,
  );
  $items['node/%node/clio/convert'] = array(
    'title' => 'Convert',
    'page callback' => 'clio_convert_convert',
    'page arguments' => array(1),
    'access callback' => 'clio_convert_convert_access',
    'access arguments' => array(1),
  );
  return $items;
}


/**
 * Implements hook_permission().
 */
function clio_convert_permission() {
  return array(
    'convert clio to csv' => array(
      'title' => t('Convert Clio Infra formatted file to row-based CSV'),
    ),
  );
}


/**
 * Access callback for convert tab.
 * Show tab only on uploaded (or linked) xsl, xlsx or csv files.
 * Do not show the tab if the resource is already converted and up-to-date.
 */
function clio_convert_convert_access($node) {
  if (node_access('view', $node) && user_access('convert clio to csv')
      && ($file = dkan_datastore_file_field($node))) { 
    if (in_array($file->filemime, 
          array('text/csv', 
                'application/vnd.ms-excel', 
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
               ))
       ) {
      $result = db_query("SELECT cnid FROM {clio} WHERE cnid = :cnid", array(':cnid' => $node->nid));
      if ($result && $result->fetchAssoc()) {
        // This is a converted resource itself.
        return FALSE;
      }
      $result = db_query("SELECT rnid, upload_time, convert_time FROM {clio} WHERE rnid = :rnid", array(':rnid' => $node->nid));
      if ($result && $row = $result->fetchAssoc()) {
        if ($row['convert_time'] && ($row['convert_time'] > $row['upload_time'])) {
          // Converted resource exists and is up-to-date.
          return FALSE;
        }
      }
      return TRUE;
    }
  }
  return FALSE;
}


/**
 * Determines status of datastore attached to resource node. 
 */
// TODO Not yet converted for convert. Combine with _access?
function clio_convert_status($node) {
  if ($file = dkan_datastore_file_field($node)) {
    if ($file->filemime == 'text/csv') {
      if (dkan_datastore_records($node->nid)) {
        return DKAN_DATASTORE_EXISTS;
      }
      else {
        return DKAN_DATASTORE_FILE_EXISTS;
      }
    }
    else {
      return DKAN_DATASTORE_WRONG_TYPE;
    }
  }
  return FALSE;
}


/*
 * TODO Check arg input
 * TODO Theme page
 *
 */
function clio_convert_page($node) {
  return l(t('Convert'), 'node/' . $node->nid . '/clio/convert');
}

/**
 * Convert and create a new resource.
 */
function clio_convert_convert($node) {

// TODO Better error handling.

  // Get the indicator from the linked dataset.
  $indicator_tid = 0;
  if (!empty($node->field_dataset_ref)) {
    $dataset_nid = $node->field_dataset_ref['und'][0]['target_id'];
    $dataset = node_load($dataset_nid);
    if (!empty($dataset->field_indicator)) {
      $indicator_tid = $dataset->field_indicator['und'][0]['tid'];
    }
  }

  // Get the file.
  $file = dkan_datastore_file_field($node);
  $filepath = drupal_realpath($file->uri);
  if ($file->filemime == 'text/csv') {
    $data = clio_convert_read_csv($filepath);
  }
  else {
    // We already checked whether it's excel
    $data = clio_convert_read_excel($filepath);
  }

  // Convert to rows.
  // TODO Split this check for better error messages.
  if (!empty($data) && ($newfile = clio_convert_to_row_based($data, $indicator_tid))) {
    // Add new resource, based on existing one.
    $nid = clio_convert_create_resource($node, $newfile);

    // TODO if in datastore then reset status; remove from store?
    
    // Display new resource.
    drupal_set_message(t('The file is converted.'));
    drupal_goto('node/'. $nid);
  }
  else {
    // Return to original resource, allowing error messages.
    drupal_set_message(t('The file could not be converted.'), 'error');
    drupal_goto('node/'. $node->nid);
  }
}


/**
 * Convert to row-based CSV.
 *
 * @param $data
 *   Array of arrays, representing the spreadsheet cells.
 * @param $indicator_tid
 *   The tid of the indicator of the referenced dataset.
 * @return $file_object
 *   A newly created file on disk.
 */
 // TODO Overwrite file if it's just an update?
function clio_convert_to_row_based($data, $indicator_tid) {
  global $user;
  // TODO Clean output strings.

  if (!($indicator = clio_convert_get_indicator($data, $indicator_tid))) {
    return;
  }
  if (!($unit = clio_convert_get_unit($data))) {
    $unit = ''; // NULL?
  }
  if (!($years = clio_convert_get_years($data))) {
    return;
  }
  if (!($countries = clio_convert_validate_countries($data))) {
    return;
  }
  
  // First create a temporary file.
  $tempdir = file_directory_temp();
  // TODO check filename?
  $filepath = file_create_filename($indicator . '.csv', $tempdir);
  
  // Write the header with field names.
  $filehandle = fopen($filepath, 'x+');
  $enclosure = '"';
  $fields = array('indicator', 'indicatortid', 'unit', 'countrycode', 'countrytid', 'year', 'value');
  fputcsv ($filehandle, $fields, CLIO_DELIMITER, $enclosure);

  // Write the values[countrycode] = array[2..]
  foreach ($data as $row) {
    if (isset($row)) {
      if (isset($row[0]) && ($row[0] != '')) {
        $countrycode = $row[0];
        $countryname = $row[1];
        foreach ($years as $key => $year) {
          // TODO what if #years does not match #values?
          // Skip NULL, blank or empty string; zeros are okay.
          $value = (isset($row[$key+2])) ? trim($row[$key+2]) : '';
          if ($value != '') {
            if (is_numeric($value)) {
              $fields = array($indicator, $indicator_tid, $unit, $countrycode, $countries[$countrycode]['tid'], $year, $value);
              fputcsv($filehandle, $fields, CLIO_DELIMITER, $enclosure);
            }
            else {
              drupal_set_message(t('Only numeric values are allowed. Found: %value', array('%value' => $value)), 'error');
              file_unmanaged_delete($filepath);
              return;
            }
          }
        }
      }
      else {
        // Non-empty row without country code.
        drupal_set_message(t('A row contains values but no country code. Perhaps some cells are shifted?'), 'error');
        file_unmanaged_delete($filepath);
        return;
      }
    }
  }
  
  // Move file to Clio data directory.
  $filename = drupal_basename($filepath);
  $destination = 'public://clio/data/'. $filename;
  if ($uri = file_unmanaged_move($filepath, $destination)) {

    // Create a file object and save in database.
    $file = new stdClass();
    $file->fid = NULL;
    $file->uri = $uri;
    $file->filename = $filename;
    $file->filemime = 'text/csv';
    $file->uid = $user->uid;
    $file->status = FILE_STATUS_PERMANENT;
    $file_object = file_save($file);
  }
  if (!empty($file_object)) {
    drupal_set_message(t('Saved CSV file as %destination', array('%destination' => $filename)));
  }
  else {
    drupal_set_message(t('Failed to save CSV file'), 'error');
    return;
  }

  return $file_object;
}


/**
 * Validate indicator and remove from data array.
 */
function clio_convert_get_indicator(&$data, $tid) {
  // The field is required so this shouldn't be necessary.
  if (empty($tid)) {
    drupal_set_message(t('The dataset this resource belongs to has no indicator.'), 'error');
    return;
  }

  // First cell on first line should contain indicator name.
  $row = array_shift($data);
  if (empty($row[0])) {
    drupal_set_message(t('No indicator found.'), 'error');
    return;
  }
  else {
    $indicator = trim($row[0]);
  }
  // Is indicator a valid term?
  $terms = taxonomy_get_term_by_name($indicator, 'indicators');
  if (empty($terms)) {
    drupal_set_message(t('Indicator not found: @indicator.', array('@indicator' => $indicator)), 'error');
    return;
  }
  if (count($terms) > 1) {
    drupal_set_message(t('Indicator name not unique: @indicator.', array('@indicator' => $indicator)), 'error');
    return;
  }

  // Is indicator the same as the one from the linked dataset?
  $term = array_shift($terms);
  if ($term->tid != $tid) {
    drupal_set_message(t('Indicator does not match dataset (@indicator1 vs @indicator2).', array('@indicator1' => $indicator, '@indicator2' => $term->name)), 'error');
    return;
  }
  return $indicator;
}


/**
 * Validate unit and remove from data array.
 */
function clio_convert_get_unit(&$data) {
  // First cell on second line may contain unit.
  // If setIterateOnlyExistingCells is set to TRUE in PHPExcel, the unit line may be missing,
  // and we'll already be on the Code line.
  // TODO So unit cannot contain "Code"?
  if (preg_match('/Code/i', $data[0][0])) {
    drupal_set_message(t('No unit found.'), 'warning');
    return;
  }
  $row = array_shift($data);
  if (is_null($row)) {
    // TODO Message is not displayed.
    drupal_set_message(t('No unit found.'), 'warning');
    return;
  }
  else {
    $unit = trim($row[0]); 
    // Remove parentheses
    $unit = preg_replace('/^\((.+)\)$/', '$1', $unit);
  }
  return $unit;
}


/**
 * Validate years and remove from data array.
 */
function clio_convert_get_years(&$data) {

  // After zero or more empty lines a header with years, along this format:
  // "Code","Continent, Region, Country",1500,1501,1502,1503,...
  $row = NULL;
  while (is_null($row) || ($row[0] == '')) {
    $row = array_shift($data);
  }
  if (!(preg_match('/Code/i', $row[0]))) {
    drupal_set_message(t('No code column found.'), 'error');
    return;
  }
  if (!(preg_match('/Continent, Region, Country/i', $row[1]))) {
    drupal_set_message(t('No country column found.'), 'error');
    return;
  }

  $years = array_slice($row, 2);
  // Are the years within range?
  $possible_years = range(1500, date('Y'));
  foreach ($years as $year) {
    if (!(in_array($year, $possible_years))) {
      drupal_set_message(t('Incorrect year: @year', array('@year' => $year)), 'error');
      return;
    }
  }
  return $years;
}


/**
 * Validate country codes and names in data array.
 * On success will return all countries, not just the ones in the data array.
 * TODO Mismatch: "code" in spreadsheet is "id" in term.
 */
function clio_convert_validate_countries($data) {
  $countries = clio_get_countries();
  $countryids = array_column($data, 0);
  $countrynames = array_column($data, 1);

  foreach ($countryids as $key => $id) {
    $name = $countrynames[$key];
    // Skip empty lines.
    if (!(empty($id) and empty($name))) {
      // TODO Country names and codes may change over time. Allow for old names? Warning instead of error?
      // See http://unstats.un.org/unsd/methods/m49/m49alpha.htm
      if (!array_key_exists($id, $countries)) {
        drupal_set_message(t('Incorrect country code: @id (@name).', array('@id' => $id, '@name' => $name)), 'error');
        return;
       }
      $countryname = $countries[$id]['name'];
      if ($name != $countryname) {
        // TODO This depends on character encoding, so e.g. Åland Islands in Latin-1 will mismatch.
        drupal_set_message(t('Country name mismatch for code @id: found @name, should be @countryname.', array('@id' => $id, '@name' => $name, '@countryname' => $countryname)), 'warning');
      }  
    }
  }
  return $countries;
}


/*
 * If a converted resource already exist, overwrite it.
 * If not create a new resource, cloning the existing one.
 *
 * @param $node
 *   The original resource which has been converted.
 *
 * @param $file
 *   The converted file.
 */
function clio_convert_create_resource($node, $file) {
  $result = db_query("SELECT cnid FROM {clio} WHERE rnid = :rnid", array(':rnid' => $node->nid));
  if ($result && ($row = $result->fetchAssoc()) && $row['cnid']) {
    // A converted resource exists.
    $converted_node = node_load($row['cnid']);
    $language = $converted_node->language;
    $converted_node->field_upload[$language][0] = (array)$file;
    $converted_node->revision = 1;
    node_save($converted_node);
    $nid = $converted_node->nid;
  }
  else {
    // Create a new node.
    $language = $node->language;
    // Create a new resource.
    $newnode = new stdClass();
    $newnode->type = 'resource';
    $newnode->language = $language;
    // Assign defaults for node object
    node_object_prepare($newnode); 
    // Replace title and file
    $newnode->title = $node->title .' (converted)';
    // Tag with csv
    $tid = clio_convert_tag_csv('csv', 'format');
    $newnode->field_format[$language][0]['tid'] = $tid; 
    $newnode->field_dataset_ref[$language][0]['target_id'] = $node->field_dataset_ref[$language][0]['target_id'];
    // TODO Copy more fields? og? recline?
    $newnode->field_upload[$language][0] = (array)$file;
    node_save($newnode);
    // TODO check success
    $nid = $newnode->nid;
  }
  return $nid;
}


/*
 * Read CSV file.
 */
function clio_convert_read_csv($csvfile, $delimiter = ',', $enclosure = '"') {
  $filehandle = fopen($csvfile, 'r');
  $rows = array();
  while (!feof($filehandle) ) {
	  $rows[] = fgetcsv($filehandle, 0, $delimiter, $enclosure);
  }
  fclose($filehandle);
  return $rows;
}


/*
 * Read Excel file.
 */
function clio_convert_read_excel($filename) {
  module_load_include('inc', 'phpexcel');

  // TODO Keep decimal precision of numbers?
  $result = phpexcel_import($filename, FALSE, FALSE, array('setReadDataOnly' => array(TRUE)));
  // $cells->setIterateOnlyExistingCells(TRUE); ? see https://drupal.org/node/2243117
  if (is_array($result)) {
    return $result[0];
  }
  // TODO On errors this should return an empty array.
  else {
    // TODO interpret error codes, see phpexcel.inc.
    drupal_set_message(t("There was an error while converting the file: ") . $result, 'error');
  }
}


/**
* Tell PHPExcel to return values instead of formulas.
*/
function clio_convert_phpexcel_import($op, &$data, $phpexcel, $options, $column = NULL, $row = NULL) {
  switch ($op) {
    case 'post cell':
      if (($column > 1) && ($row > 1)) {
        try {
          // TODO Reference to other files doesn't work. Resulting value is #REF!
          $data = $phpexcel->getCalculatedValue();
        } catch (Exception $e) {
          // TODO Break after first error
          drupal_set_message(t("Error converting cell: ") . $e->getMessage(), 'error');
        }
      }
      break;
  }
}


/**
 * Helper function to dynamically get the tid from the term_name
 * or add the term
 *
 * @param $term_name 
 *   Term name
 * @param $vocabulary_name 
 *   Name of the vocabulary to search the term in
 *
 * @return Term id of the found or newly added term
 */
function clio_convert_tag_csv($term_name, $vocabulary_name) {
  if ($vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_name)) {

    // $csv = taxonomy_get_term_by_name($name, $vocabulary->vid);
    // $tid = array_shift($result['taxonomy_term'])->tid;

    $tree = taxonomy_get_tree($vocabulary->vid);
    foreach ($tree as $term) {
      if ($term->name == $term_name) {
        return $term->tid;
      }
    }
    $term = new stdClass();
    $term->name = $term_name;
    $term->vid = $vocabulary->vid;
    taxonomy_term_save($term);
    return $term->tid;
  }
  return FALSE;
}


